<script type="text/x-mathjax-config;">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" id=""></script>

    <!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		<meta name="description" content="whatever">
		<meta name="generator" content="Hugo 0.30.2" />
		<title>bzoj2819题解 &middot; 蒟蒻的博客</title>
		<link rel="shortcut icon" href="http://blog.eleele.gq/images/favicon.ico">
		<link rel="stylesheet" href="http://blog.eleele.gq/css/style.css">
		<link rel="stylesheet" href="http://blog.eleele.gq/css/highlight.css">
		

		
		<link rel="stylesheet" href="http://blog.eleele.gq/css/monosocialiconsfont.css">
		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='http://blog.eleele.gq/'> <span class="arrow">←</span>Home</a>
	
	<a href='http://blog.eleele.gq/post'>Archive</a>
	<a href='http://blog.eleele.gq/tags'>Tags</a>
	<a href='http://blog.eleele.gq/about'>About</a>

	

	
	
	<a href='http://blog.eleele.gq/orz'>Orz!</a>
</nav>


        <section id="wrapper">
            <article class="post">
                <header>
                    <h1>
                        bzoj2819题解
                    </h1>
                    <h2 class="headline">
                    Sep 8, 2016 10:02
                    · 280 words
                    · 2 minutes read
                      <span class="tags">
                      
                      
                          
                              <a href="http://blog.eleele.gq/tags/%E9%A2%98%E8%A7%A3">题解</a>
                          
                              <a href="http://blog.eleele.gq/tags/bzoj">bzoj</a>
                          
                              <a href="http://blog.eleele.gq/tags/%E6%AC%A7%E6%8B%89%E5%BA%8F%E5%88%97">欧拉序列</a>
                          
                              <a href="http://blog.eleele.gq/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91">线段树</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                <section id="post-body">
                    <p></p>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="http://music.163.com/outchain/player?type=2&id=25880423&auto=0&height=66"></iframe>

<p>即要支持两个操作：链上求异或、修改一个数。</p>

<p>用欧拉序列，维护每个点到根路径上的数的异或就可以做了。</p>

<p>dfs只传一个参的话不会爆栈。</p>

<p>代码：</p>

<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define ele int
using namespace std;
#define maxn 500010
struct node
{
    ele res,tag,midx;
    node *l,*r;
}pool[maxn&lt;&lt;3];
ele ncnt,a[maxn],dep[maxn],seq[maxn&lt;&lt;1],w[maxn];
inline void maintain(node *x)
{
    if (!x) return;
    x-&gt;res=x-&gt;tag;
    if (x-&gt;l) x-&gt;res^=x-&gt;l-&gt;res^x-&gt;r-&gt;res;
}
node* build(ele l,ele r)
{
    node *p=&amp;pool[ncnt++];
    if (l==r)
    {
        p-&gt;l=p-&gt;r=NULL;
        p-&gt;res=p-&gt;tag=w[seq[l]];
        p-&gt;midx=seq[l];
    }
    else
    {
        ele mid=(l+r)&gt;&gt;1;
        p-&gt;l=build(l,mid);
        p-&gt;r=build(mid+1,r);
        if (dep[p-&gt;l-&gt;midx]&lt;dep[p-&gt;r-&gt;midx]) p-&gt;midx=p-&gt;l-&gt;midx; else p-&gt;midx=p-&gt;r-&gt;midx;
        p-&gt;tag=0;
        maintain(p);
    }
    return p;
}
void upd(node *x,ele a,ele b,ele l,ele r,ele k)
{
    if (l&lt;=a &amp;&amp; b&lt;=r) x-&gt;tag^=k;
    else
    {
        ele mid=(a+b)&gt;&gt;1;
        if (l&lt;=mid) upd(x-&gt;l,a,mid,l,r,k);
        if (mid&lt;r) upd(x-&gt;r,mid+1,b,l,r,k);
    }
    maintain(x);
}
ele query(node *x,ele a,ele b,ele i)
{
    if (a==b) return x-&gt;res;
    ele mid=(a+b)&gt;&gt;1;
    if (i&lt;=mid) return query(x-&gt;l,a,mid,i)^x-&gt;tag;
    else return query(x-&gt;r,mid+1,b,i)^x-&gt;tag;
}
ele lca(node *x,ele a,ele b,ele l,ele r)
{
    if (l&lt;=a &amp;&amp; b&lt;=r) return x-&gt;midx;
    ele mid=(a+b)&gt;&gt;1,ans=-1,tmp;
    if (l&lt;=mid)
        if (dep[tmp=lca(x-&gt;l,a,mid,l,r)]&lt;dep[ans] || ans==-1) ans=tmp;
    if (mid&lt;r)
        if (dep[tmp=lca(x-&gt;r,mid+1,b,l,r)]&lt;dep[ans] || ans==-1) ans=tmp;
    return ans;
}
struct edge
{
    ele v;
    edge *nxt;
}epool[maxn&lt;&lt;1];
ele n,q,ecnt,pos[maxn],scnt,fa[maxn],end[maxn];
edge *h[maxn];
node *root;
inline void addedge(ele u,ele v)
{
    edge *p=&amp;epool[ecnt++];
    p-&gt;v=v; p-&gt;nxt=h[u];
    h[u]=p;
}
void dfs(ele i)
{
    pos[i]=scnt;
    seq[scnt++]=i;
    for (edge *j=h[i]; j; j=j-&gt;nxt)
        if (pos[j-&gt;v]==-1)
        {
            dep[j-&gt;v]=dep[i]+1;
            w[j-&gt;v]=w[i]^a[j-&gt;v];
            fa[j-&gt;v]=i;
            dfs(j-&gt;v);
            seq[scnt++]=i;
        }
    end[i]=scnt-1;
}
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    for (int i=0; i&lt;n; ++i) scanf(&quot;%d&quot;,a+i);
    ecnt=0;
    memset(h,0,sizeof(h));
    for (int i=0; i&lt;n-1; ++i)
    {
        ele u,v;
        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
        --u,--v;
        addedge(u,v); addedge(v,u);
    }
    ncnt=0; scnt=0; dep[0]=0; w[0]=a[0]; fa[0]=-1;
    memset(pos,-1,sizeof(pos));
    dfs(0);
    root=build(0,scnt-1);
    scanf(&quot;%d&quot;,&amp;q);
    char s[10];
    ele u,v,w;
    while (q--)
    {
        scanf(&quot;%s%d%d&quot;,s,&amp;u,&amp;v);
        if (s[0]=='Q')
        {
            --u,--v;
            if (pos[u]&gt;pos[v]) swap(u,v);
            w=lca(root,0,scnt-1,pos[u],pos[v]);
            ele a1=query(root,0,scnt-1,pos[u]);
            ele a2=query(root,0,scnt-1,pos[v]);
            ele a3=query(root,0,scnt-1,pos[w]);
            ele a4=(fa[w]==-1)?(0):(query(root,0,scnt-1,pos[fa[w]]));
            if (a1^a2^a3^a4) puts(&quot;Yes&quot;); else puts(&quot;No&quot;);
            //printf(&quot;%d\n&quot;,a1^a2^a3^a4);
        }
        else
        {
            --u;
            ele tmp=query(root,0,scnt-1,pos[u]);
            ele tmp1=(fa[u]==-1)?(0):(query(root,0,scnt-1,pos[fa[u]]));
            upd(root,0,scnt-1,pos[u],end[u],tmp^tmp1^v);
        }
    }
    return 0;
}
</code></pre>
                </section>
            </article>

            

            

            

            <footer id="footer">
    
    <p class="small">
    
       © Copyright 2017 <i class="fa fa-heart" aria-hidden="true"></i> 
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>
        </section>

        <script src="http://blog.eleele.gq/js/jquery-2.2.4.min.js"></script>
<script src="http://blog.eleele.gq/js/main.js"></script>
<script src="http://blog.eleele.gq/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>







    </body>
</html>
