Title: bzoj1001题解
Tags: 题解,bzoj,dijkstra,平面图
Date: 2016-12-12

<!--more-->
<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

平面图最小割等于对偶图最短路，可以去看一看[这个东西](http://wenku.baidu.com/view/5a7df375a417866fb84a8e54.html)。

几年前就该来写这道题的……拖到现在……

要特判一下n，m中有一个是1的情况。

代码：
```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#define ele int
using namespace std;
#define maxn 1010
#define maxv 2000010
#define INF 1000000000
struct hn{
	ele i,d;
	inline bool operator<(hn b)const{
		return d>b.d;
	}
};
struct edge{
	ele v,w;
	edge *nxt;
}ep[maxv<<2];
ele n,m,a[maxn][maxn],b[maxn][maxn],c[maxn][maxn],ecnt;
edge *g[maxv];
inline ele idx(ele i,ele j,ele k){
	return 2+(i*(m-1)+j)*2+k;
}
inline void addedge(ele u,ele v,ele w){
	edge *p=&ep[ecnt++];
	p->v=v; p->w=w; p->nxt=g[u];
	g[u]=p;
}
inline ele dij(ele s,ele t,ele v){
	static priority_queue<hn> q;
	static ele d[maxv];
	static bool vis[maxv];
	memset(d,-1,sizeof(d));
	memset(vis,0,sizeof(vis));
	d[s]=0;
	q.push({s,0});
	while (!q.empty()){
		hn k=q.top(); q.pop();
		if (vis[k.i]) continue;
		vis[k.i]=true;
		for (edge *j=g[k.i]; j; j=j->nxt)
			if (d[j->v]==-1 || d[j->v]>k.d+j->w){
				d[j->v]=k.d+j->w;
				q.push({j->v,d[j->v]});
			}
	}
	return d[t];
}
int main(){
	scanf("%d%d",&n,&m);
	for (int i=0; i<n; ++i)
		for (int j=0; j<m-1; ++j)
			scanf("%d",&a[i][j]);
	for (int i=0; i<n-1; ++i)
		for (int j=0; j<m; ++j)
			scanf("%d",&b[i][j]);
	for (int i=0; i<n-1; ++i)
		for (int j=0; j<m-1; ++j)
			scanf("%d",&c[i][j]);
	for (int j=0; j<m-1; ++j)
		addedge(0,idx(0,j,0),a[0][j]);
	for (int i=0; i<n-1; ++i)
		addedge(0,idx(i,m-2,0),b[i][m-1]);
	for (int i=0; i<n-1; ++i)
		addedge(idx(i,0,1),1,b[i][0]);
	for (int j=0; j<m-1; ++j)
		addedge(idx(n-2,j,1),1,a[n-1][j]);
	for (int i=0; i<n-1; ++i)
		for (int j=0; j<m-1; ++j)
			addedge(idx(i,j,0),idx(i,j,1),c[i][j]),
			addedge(idx(i,j,1),idx(i,j,0),c[i][j]);
	for (int i=0; i<n-1; ++i)
		for (int j=0; j<m-2; ++j)
			addedge(idx(i,j,0),idx(i,j+1,1),b[i][j+1]),
			addedge(idx(i,j+1,1),idx(i,j,0),b[i][j+1]);
	for (int j=0; j<m-1; ++j)
		for (int i=0; i<n-2; ++i)
			addedge(idx(i,j,1),idx(i+1,j,0),a[i+1][j]),
			addedge(idx(i+1,j,0),idx(i,j,1),a[i+1][j]);
	ele ans=INF;
	if (n>1 && m>1)
		ans=dij(0,1,idx(n-1,m-1,1)+1);
	else if (n==1)
		for (int j=0; j<m-1; ++j)
			ans=min(ans,a[0][j]);
	else
		for (int i=0; i<n-1; ++i)
			ans=min(ans,b[i][0]);
	if (n==1 && m==1) ans=0;
	printf("%d\n",ans);
	return 0;
}
```