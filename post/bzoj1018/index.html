<script type="text/x-mathjax-config;">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" id=""></script>

    <!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		<meta name="description" content="whatever">
		<meta name="generator" content="Hugo 0.30.2" />
		<title>bzoj1018题解 &middot; 蒟蒻的博客</title>
		<link rel="shortcut icon" href="http://blog.eleele.gq/images/favicon.ico">
		<link rel="stylesheet" href="http://blog.eleele.gq/css/style.css">
		<link rel="stylesheet" href="http://blog.eleele.gq/css/highlight.css">
		

		
		<link rel="stylesheet" href="http://blog.eleele.gq/css/monosocialiconsfont.css">
		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='http://blog.eleele.gq/'> <span class="arrow">←</span>Home</a>
	
	<a href='http://blog.eleele.gq/post'>Archive</a>
	<a href='http://blog.eleele.gq/tags'>Tags</a>
	<a href='http://blog.eleele.gq/about'>About</a>

	

	
	
	<a href='http://blog.eleele.gq/orz'>Orz!</a>
</nav>


        <section id="wrapper">
            <article class="post">
                <header>
                    <h1>
                        bzoj1018题解
                    </h1>
                    <h2 class="headline">
                    May 14, 2017 10:02
                    · 231 words
                    · 2 minutes read
                      <span class="tags">
                      
                      
                          
                              <a href="http://blog.eleele.gq/tags/%E9%A2%98%E8%A7%A3">题解</a>
                          
                              <a href="http://blog.eleele.gq/tags/bzoj">bzoj</a>
                          
                              <a href="http://blog.eleele.gq/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86">并查集</a>
                          
                              <a href="http://blog.eleele.gq/tags/%E6%8C%89%E6%97%B6%E9%97%B4%E5%88%86%E6%B2%BB">按时间分治</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                <section id="post-body">
                    <p></p>

<p>我们考虑一个更一般的问题——动态维护图的连通性。</p>

<p>在线的做法我还不会，但是如果离线的话，有一个非常妙的做法。</p>

<p>用一棵线段树维护时间轴，每一条边在时间轴中存在一定的时间。这些时间可以像区间修改那样对应到线段树的若干个节点。每个节点维护一个vector，这个vector里面的边在该节点代表的时间段里均存在。</p>

<p>接着对这棵线段树dfs，用一个并查集维护图的联通性，每到达一个节点，就把这个节点的vector里面的所有边加进去。每到达一个叶子节点，就可以利用并查集回答相应的询问。回朔的时候需要删边，但删边是很困难的。不过注意到这里只需要撤销加入的边，那么在每个节点上维护当时对并查集的修改，然后回朔的时候改回去就可以了。</p>

<p>路径压缩的势能分析在有撤销操作时会失效，因此要写按大小和并，时间复杂度$O(n\log n)$。</p>

<p>写合并的时候脑残忘了判断两点在同一集合中的情况……</p>

<p>其实，对于那些有插入和删除操作，删除很困难但撤销插入相对容易的问题，按时间分治往往是很有用的想法。</p>

<p>代码：</p>

<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#define ele int
using namespace std;
#define maxn 200010
struct edge{
	ele u,v;
};
struct node{
	vector&lt;edge&gt; e;
	node *l,*r;
}np[maxn&lt;&lt;2],*ncnt;
node* build(ele l,ele r){
	node *p=ncnt++;
	p-&gt;e.clear();
	if (l==r) p-&gt;l=p-&gt;r=NULL;
	else{
		ele mid=(l+r)&gt;&gt;1;
		p-&gt;l=build(l,mid);
		p-&gt;r=build(mid+1,r);
	}
	return p;
}
void upd(node *x,ele a,ele b,ele l,ele r,edge e){
	if (l&gt;r) return;
	if (l&lt;=a &amp;&amp; b&lt;=r) x-&gt;e.push_back(e);
	else{
		ele mid=(a+b)&gt;&gt;1;
		if (l&lt;=mid) upd(x-&gt;l,a,mid,l,r,e);
		if (mid&lt;r) upd(x-&gt;r,mid+1,b,l,r,e);
	}
}
ele n,m,Q,acnt,ty[maxn],p[maxn&lt;&lt;1],u[maxn];
bool res[maxn];
edge q[maxn],q1[maxn];
char s[10];
node *root;
inline ele idx(ele x,ele y){
	--x,--y;
	return x*(n&gt;&gt;1)+y;
}
ele getf(ele *u,ele x){
	return (u[x]&lt;0)?x:getf(u,u[x]);
}
void dfs(node *x){
	vector&lt;ele&gt; v1,v2,v3,v4;
	v1.clear(); v2.clear(); v3.clear(); v4.clear();
	for (int i=0; i&lt;x-&gt;e.size(); ++i){
		ele a=getf(u,x-&gt;e[i].u),b=getf(u,x-&gt;e[i].v);
		if (a==b) continue;
		if (u[a]&gt;u[b]) swap(a,b);
		v1.push_back(a); v2.push_back(u[a]);
		v3.push_back(b); v4.push_back(u[b]);
		u[a]+=u[b]; u[b]=a;
	}
	if (x-&gt;l){
		dfs(x-&gt;l); dfs(x-&gt;r);
	}
	else{
		res[acnt]=(getf(u,q1[acnt].u)==getf(u,q1[acnt].v));
		++acnt;
	}
	for (int i=v1.size()-1; ~i; --i){
		u[v1[i]]=v2[i];
		u[v3[i]]=v4[i];
	}
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	n&lt;&lt;=1;
	Q=0;
	for (m=0; ; ++m){
		scanf(&quot;%s&quot;,s);
		if (s[0]=='E') break;
		ele a,b,c,d;
		scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d);
		q[m]=(edge){idx(a,b),idx(c,d)};
		if (s[0]=='O') ty[m]=0;
		else if (s[0]=='C') ty[m]=1;
		else if (s[0]=='A') ty[m]=2,q1[Q++]=q[m];
	}
	ncnt=np;
	root=build(0,Q-1);
	memset(p,-1,sizeof(p));
	for (int i=0,j=0; i&lt;m; ++i)
		if (ty[i]==0){
			if (!~p[q[i].u+q[i].v]) p[q[i].u+q[i].v]=j;
		}
		else if (ty[i]==1){
			if (~p[q[i].u+q[i].v])
				upd(root,0,Q-1,p[q[i].u+q[i].v],j-1,q[i]),p[q[i].u+q[i].v]=-1;
		}
		else ++j;
	for (int i=0; i&lt;m; ++i)
		if (!ty[i] &amp;&amp; ~p[q[i].u+q[i].v])
			upd(root,0,Q-1,p[q[i].u+q[i].v],Q-1,q[i]),p[q[i].u+q[i].v]=-1;
	memset(u,-1,sizeof(u));
	acnt=0;
	dfs(root);
	for (int i=0; i&lt;Q; ++i) puts(res[i]?&quot;Y&quot;:&quot;N&quot;);
	return 0;
}
</code></pre>
                </section>
            </article>

            

            

            

            <footer id="footer">
    
    <p class="small">
    
       © Copyright 2017 <i class="fa fa-heart" aria-hidden="true"></i> 
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>
        </section>

        <script src="http://blog.eleele.gq/js/jquery-2.2.4.min.js"></script>
<script src="http://blog.eleele.gq/js/main.js"></script>
<script src="http://blog.eleele.gq/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>







    </body>
</html>
