<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>动态图 on 蒟蒻的博客</title>
    <link>http://blog.eleele.gq/tags/%E5%8A%A8%E6%80%81%E5%9B%BE/</link>
    <description>Recent content in 动态图 on 蒟蒻的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 31 Dec 2017 13:36:49 +0000</lastBuildDate>
    
	<atom:link href="http://blog.eleele.gq/tags/%E5%8A%A8%E6%80%81%E5%9B%BE/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>loj122题解</title>
      <link>http://blog.eleele.gq/post/loj122/</link>
      <pubDate>Sun, 31 Dec 2017 13:36:49 +0000</pubDate>
      
      <guid>http://blog.eleele.gq/post/loj122/</guid>
      <description>写+调了7h+，终于成为AC此题的第四个人+此题目前最短代码+此题目前最慢代码……
去CA的博客上翻WC2015 xyz的课件来看吧……虽然看懂了但是完全不想写题解……太复杂了……
代码：
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;queue&amp;gt; #define ele int using namespace std; #define maxn 5010 #define maxm 500010 #define maxk 15 namespace LCT{ struct node{ ele s,vir; bool flip; node *f,*c[2]; node(){ s=1; vir=0; flip=false; f=c[0]=c[1]=NULL; } }; inline bool splayroot(node *x){ return (!x-&amp;gt;f || (x-&amp;gt;f-&amp;gt;c[0]!=x &amp;amp;&amp;amp; x-&amp;gt;f-&amp;gt;c[1]!=x)); } inline void pushdown(node *x){ if (x &amp;amp;&amp;amp; x-&amp;gt;flip){ swap(x-&amp;gt;c[0],x-&amp;gt;c[1]); if (x-&amp;gt;c[0]) x-&amp;gt;c[0]-&amp;gt;flip^=1; if (x-&amp;gt;c[1]) x-&amp;gt;c[1]-&amp;gt;flip^=1; x-&amp;gt;flip=false; } } inline void maintain(node *x){ x-&amp;gt;s=1+x-&amp;gt;vir; if (x-&amp;gt;c[0]) x-&amp;gt;s+=x-&amp;gt;c[0]-&amp;gt;s; if (x-&amp;gt;c[1]) x-&amp;gt;s+=x-&amp;gt;c[1]-&amp;gt;s; } inline node* rotate(node *x,ele k){ if (!</description>
    </item>
    
  </channel>
</rss>