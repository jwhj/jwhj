<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jzoj on 蒟蒻的博客</title>
    <link>http://blog.eleele.gq/tags/jzoj/</link>
    <description>Recent content in Jzoj on 蒟蒻的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 20 Jan 2018 14:27:24 +0000</lastBuildDate>
    
	<atom:link href="http://blog.eleele.gq/tags/jzoj/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>jzoj5523题解</title>
      <link>http://blog.eleele.gq/post/jz5523/</link>
      <pubDate>Sat, 20 Jan 2018 14:27:24 +0000</pubDate>
      
      <guid>http://blog.eleele.gq/post/jz5523/</guid>
      <description>看AC人数来看应该是全场最简单的一道题，可是我就这道题没做出来……sbwhj……
首先注意到在加号后面加括号是毫无意义的，所以我们可以钦定括号只能加在减号后面。此时括号的作用就是把里面除了第一个数以外的所有数的贡献取负，那我们又可以得到两层以上的括号嵌套总能改成不超过两层的括号嵌套。
让f[i][0/1/2]表示考虑前i个数，式子最后有0/1/2个右括号的时候的最大值。转移的时候，按运算符分两种情况讨论：
 减号。此时这个数可以新开一个括号，即-(A)，贡献为-A；也可以塞到前面的括号里面或者放在前面括号外面，贡献为+A或-A，视塞的层数奇偶性而定。 加号。此时这个数不能新开一个括号，只能塞到前面的括号里面或者放在最外面。  代码：
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #define ele long long using namespace std; #define maxn 100010 const ele INF=1e18; ele n,a[maxn],f[maxn][3]; bool b[maxn]; char s[100]; int main(){ //freopen(&amp;quot;calculate.in&amp;quot;,&amp;quot;r&amp;quot;,stdin); freopen(&amp;quot;calculate.out&amp;quot;,&amp;quot;w&amp;quot;,stdout); scanf(&amp;quot;%lld&amp;quot;,&amp;amp;n); for (int i=0; i&amp;lt;n*2-1; ++i){ scanf(&amp;quot;%s&amp;quot;,s); if (i&amp;amp;1) b[(i+1)&amp;gt;&amp;gt;1]=(s[0]==&#39;+&#39;); else{ ele tmp=0,L=strlen(s); for (int i=0; i&amp;lt;L; ++i) tmp=(tmp&amp;lt;&amp;lt;3)+(tmp&amp;lt;&amp;lt;1)+s[i]-&#39;0&#39;; a[i&amp;gt;&amp;gt;1]=tmp; } } f[0][0]=a[0]; f[0][1]=f[0][2]=-INF; for (int i=0; i&amp;lt;n-1; ++i) if (b[i+1]){ f[i+1][0]=max(max(f[i][0],f[i][1]),f[i][2])+a[i+1]; f[i+1][1]=max(f[i][1],f[i][2])-a[i+1]; f[i+1][2]=f[i][2]+a[i+1]; } else{ f[i+1][0]=max(max(f[i][0],f[i][1]),f[i][2])-a[i+1]; f[i+1][1]=max(f[i][1],f[i][2])+a[i+1]; f[i+1][1]=max(f[i+1][1],f[i][0]-a[i+1]); f[i+1][2]=max(f[i][1],f[i][2])+a[i+1]; } printf(&amp;quot;%lld\n&amp;quot;,max(max(f[n-1][0],f[n-1][1]),f[n-1][2])); return 0; }  </description>
    </item>
    
    <item>
      <title>jzoj5260题解</title>
      <link>http://blog.eleele.gq/post/jz5260/</link>
      <pubDate>Tue, 09 Jan 2018 14:41:56 +0000</pubDate>
      
      <guid>http://blog.eleele.gq/post/jz5260/</guid>
      <description>首先不管强制在线，不管数据范围，只考虑设计一个亚二次的算法，显然可以用莫队+值域线段树在$O(n\sqrt{n}\log n)$的时间内解决。但是这个做法会爆0+卡爆机房的奔腾cpu电脑……
注意到在莫队算法中，因端点改变对值域线段树造成的修改有$O(n\sqrt{n})$次，但是对值域线段树的询问只有$O(n)$次，所以可以考虑牺牲询问来加速修改。
考虑对值域也分块，维护每个块里面出现次数&amp;lt;=w的数的总出现次数，以及每个数具体的出现次数，就可以做到$O(n\sqrt{n})$。
最后再把莫队改成强制在线的莫队，预处理出f[i][j][k]表示第i块到第j块中，值在第k块中的，出现次数&amp;lt;=w的数的出现次数，以及g[i][j]表示前i块中j的出现次数。
写的时候因为一个sb错误debug了很久，以后要注意，为了代码简单把几种情况归成一种情况写的时候，需要仔细研究几种情况的不同点。比方说，l，r在同一块的时候，就不要写出g[r/S-1][j]这样优秀的潜在未定义行为（因为r可能在第0块）。
代码：
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cmath&amp;gt; #define ele int using namespace std; #define maxn 100010 #define maxb 320 ele n; struct arr{ ele t,a[maxn],b[maxn]; arr(){ t=0; memset(b,0,sizeof(b)); } inline ele&amp;amp; operator[](ele i){ if (b[i]&amp;lt;t) b[i]=t,a[i]=0; return a[i]; } }; ele w,q,ty,S,bcnt,a[maxn],f[maxb][maxb][maxb],g[maxb][maxn],tmp[maxb]; arr cnt; inline ele calc(ele l,ele r,ele x){ if (l/S&amp;lt;r/S) return cnt[x]+g[r/S-1][x]-g[l/S][x]; else return cnt[x]; } int main(){ scanf(&amp;quot;%d%d%d%d&amp;quot;,&amp;amp;n,&amp;amp;w,&amp;amp;q,&amp;amp;ty); for (int i=0; i&amp;lt;n; ++i) scanf(&amp;quot;%d&amp;quot;,a+i); S=sqrt(n); bcnt=0; for (int i=0; i&amp;lt;n; i+=S,++bcnt) for (int j=i; j&amp;lt;n &amp;amp;&amp;amp; j&amp;lt;i+S; ++j) ++g[bcnt][a[j]]; for (int i=1; i&amp;lt;bcnt; ++i) for (int j=0; j&amp;lt;n; ++j) g[i][j]+=g[i-1][j]; memset(f,0,sizeof(f)); for (int i=0; i&amp;lt;bcnt; ++i){ ++cnt.</description>
    </item>
    
    <item>
      <title>jzoj3766&amp;&amp;bzoj4530题解</title>
      <link>http://blog.eleele.gq/post/jzoj3766bzoj4530/</link>
      <pubDate>Sun, 31 Dec 2017 13:25:39 +0000</pubDate>
      
      <guid>http://blog.eleele.gq/post/jzoj3766bzoj4530/</guid>
      <description>有各种离线的做法，不过我感觉用lct在线做比较优雅。
这道题其实就是要求出子树大小，如果用lct来做的话，其实不需要考虑子树信息的维护，只需要能够维护整棵树的信息，查询的时候cut一下就好了。
lct上存在x-&amp;gt;f为y，但y的左右儿子均不为x的情况，这个时候，我们称x为y的虚儿子。考虑对于每个splay的节点，额外维护一个域vir表示它的所有虚儿子的信息和，那就可以求出整棵树的信息了。而这个vir只会在access和link的时候被修改。
感觉不太会BB……可以看一下这篇题解。
代码：
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #define ele int using namespace std; #define maxn 100010 namespace LCT{ struct node{ ele s,vir; bool flip; node *f,*c[2]; node(){ s=1; vir=0; flip=false; f=c[0]=c[1]=NULL; } }np[maxn]; inline bool splayroot(node *x){ return (!x-&amp;gt;f || (x-&amp;gt;f-&amp;gt;c[0]!=x &amp;amp;&amp;amp; x-&amp;gt;f-&amp;gt;c[1]!=x)); } inline void pushdown(node *x){ if (x &amp;amp;&amp;amp; x-&amp;gt;flip){ swap(x-&amp;gt;c[0],x-&amp;gt;c[1]); if (x-&amp;gt;c[0]) x-&amp;gt;c[0]-&amp;gt;flip^=1; if (x-&amp;gt;c[1]) x-&amp;gt;c[1]-&amp;gt;flip^=1; x-&amp;gt;flip=false; } } inline void maintain(node *x){ x-&amp;gt;s=1+x-&amp;gt;vir; if (x-&amp;gt;c[0]) x-&amp;gt;s+=x-&amp;gt;c[0]-&amp;gt;s; if (x-&amp;gt;c[1]) x-&amp;gt;s+=x-&amp;gt;c[1]-&amp;gt;s; } inline node* rotate(node *x,ele k){ if (!</description>
    </item>
    
    <item>
      <title>纪中noip2017模拟赛总结</title>
      <link>http://blog.eleele.gq/post/jznoip2017/</link>
      <pubDate>Mon, 30 Oct 2017 12:57:04 +0000</pubDate>
      
      <guid>http://blog.eleele.gq/post/jznoip2017/</guid>
      <description>没什么状态写……慢慢完善吧……
10-24 在前面
10-25 雅礼原题
10-26 A了的2道题都做得比标算复杂……不过rk1了还是不错的。
T1专治像我这样的莫比乌斯反演学傻，直接考虑几何意义就可以了……
T2发现其实就是在dfs序上选若干个不相交的子树，随便做……
T3是一个非常奥妙的dp，我的50分做法虽然比标算复杂，但是可以拓展到100分，思路大概是是把代价转化为到线段中点距离的两倍，再稍微修改一下状态的表示，利用决策单调性进行dp。
10-27 T1没什么好说的……码一大段一大段的代码就可以了。
T2我被排列这个条件给干扰了，结果就去想置换群一直没想出来。其实排列这个条件的作用不是很大，原来的问题可以拆成两个相同的问题，然后简单地DP+容斥即可解决。感觉先DP出一个带重复的东西，再容斥掉这个思路挺妙的。
T3我本来想到了分治，可当时模模糊糊地认为过不了就没写……这种题首先应该注意到图很小，可以把所有点对最短路看成区间上的一个信息，这样区间的信息还可以合并。但如果直接写线段树的话，维护的信息远多于每次查询的信息，所以可以用这道题这样的分治的思路。
10-28 T1用一棵平衡树乱搞。
T2奇妙的贪心，首先考虑xi=0的情况怎么贪，然后考虑拓展到xi!=0的情况，发现选y的部分和选z的部分同样满足某个性质，从而把做法拓展。
T3我本来的思路是，给每条k-x的边附加一个权值，再做最小生成树，二分这个权值来得到x系数不同的时候对应的最小常数项。但是这个思路是不能用在不保证一定有解的情况下的。正确的思路是考虑由k+x组成的树，随着x增大，向k-x组成的树变化的情况。为什么还要写LCT啊……
10-30 T1和T2都是大水题。
T3的差分是一个非常妙的思路。</description>
    </item>
    
    <item>
      <title>jzoj5407题解</title>
      <link>http://blog.eleele.gq/post/jz5407/</link>
      <pubDate>Thu, 26 Oct 2017 00:20:03 +0000</pubDate>
      
      <guid>http://blog.eleele.gq/post/jz5407/</guid>
      <description>我博弈论好废啊……
归纳证明A，B都不为0的时候，答案是A-B-2.
首先，后手总能不断消耗先手的水晶，直到对方只剩一个，从而达到答案。
先手出了一枚水晶之后，如果后手接着出，相当于先后手互换，本来的先手只要采用相同的策略，不断消耗后手的水晶，最后的结果对后手就已经更为不利，所以后手不可能接着出。
用归纳证一下最优性就可以了。
代码：
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #define ele int using namespace std; int main(){ //	freopen(&amp;quot;deep.in&amp;quot;,&amp;quot;r&amp;quot;,stdin); //	freopen(&amp;quot;deep.out&amp;quot;,&amp;quot;w&amp;quot;,stdout); ele T; scanf(&amp;quot;%d&amp;quot;,&amp;amp;T); while (T--){ ele a,b; scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b); if (!a) printf(&amp;quot;%d\n&amp;quot;,-b); else if (!b) printf(&amp;quot;%d\n&amp;quot;,a); else printf(&amp;quot;%d\n&amp;quot;,a-b-2); } return 0; }  </description>
    </item>
    
    <item>
      <title>纪中模拟赛10-24总结</title>
      <link>http://blog.eleele.gq/post/jz10-24/</link>
      <pubDate>Tue, 24 Oct 2017 13:53:30 +0000</pubDate>
      
      <guid>http://blog.eleele.gq/post/jz10-24/</guid>
      <description>开考的时候先看了一眼T1，发现题面似乎有点问题，于是跳到T2。
看T2的时候，马上想到拓扑序列计数，然而并不会做，还忽略了每个点出度不超过1这个条件。
于是我打了一下T2的暴力，回去看T1，发现题面已经更正了，就打了暴力和正解放在一遍拍着。接着我回去想T2，卡了很久没想出来，最后看到之前忽略了的那个条件，然后……就秒掉了。
此时只剩下1h，我变得很慌，T3成功5分滚粗。
最后看成绩0+100+5=105
T1的话，数据应该是错了，经胡乱修改+测试，数据更正的话我应该能100，这个就没啥可说了。
T2我读错题这个过于sb。以后看到题，就算有想法，也一定要坚持仔细读完题目，因为这个想法未必是对的，而且这样很容易漏条件，我好像就漏过好几次了。
T3滚粗主要还是因为太慌没想清楚？中午吃饭的时候随便想想也就会做了。不过挺考码力的，另外如果写成$O(q\log^2 n)$的话需要优化一下才能过。我采取的优化主要是，寻找左右第一个可行位置时，直接在线段树上二分，省去这部分的一个log，再用预编译命令开O2。不知道为什么预编译命令开的O2好像没有直接命令行开O2快？
题解就不写了，还是挺简单的。
代码（T1）：
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #define ele long long using namespace std; #define maxn 810 #define maxk 10 const ele INF=1e9; ele n,m,q,_log[maxn],a[maxn][maxn],b[maxn][maxn]; struct st{ ele a[maxn][maxn],f[maxn][maxn][maxk]; inline void init(){ for (int i=0; i&amp;lt;n; ++i) for (int j=0; j&amp;lt;m; ++j) f[i][j][0]=a[i][j]; for (int k=1; k&amp;lt;maxk; ++k) for (int i=0; i&amp;lt;n; ++i) for (int j=0; j&amp;lt;m; ++j){ f[i][j][k]=f[i][j][k-1]; ele L=1&amp;lt;&amp;lt;(k-1); if (i+L&amp;lt;n) f[i][j][k]=min(f[i][j][k],f[i+L][j][k-1]); if (j+L&amp;lt;m) f[i][j][k]=min(f[i][j][k],f[i][j+L][k-1]); if (i+L&amp;lt;n &amp;amp;&amp;amp; j+L&amp;lt;m) f[i][j][k]=min(f[i][j][k],f[i+L][j+L][k-1]); } } inline ele qry(ele i,ele j,ele L){ ele k=_log[L],L1=1&amp;lt;&amp;lt;k; ele ans=INF; ans=min(ans,f[i][j][k]); ans=min(ans,f[i+L-L1][j][k]); ans=min(ans,f[i][j+L-L1][k]); ans=min(ans,f[i+L-L1][j+L-L1][k]); return ans; } inline ele qry(ele x1,ele y1,ele x2,ele y2){ ele Lx=x2-x1+1,Ly=y2-y1+1; ele ans=INF; if (Lx&amp;lt;Ly){ for (ele y=y1; y&amp;lt;=y2; y+=Lx) ans=min(ans,qry(x1,min(y,y2-Lx+1),Lx)); } else{ for (ele x=x1; x&amp;lt;=x2; x+=Ly) ans=min(ans,qry(min(x,x2-Ly+1),y1,Ly)); } return ans; } }qmx,qmn; int main(){ //	freopen(&amp;quot;phalanx.</description>
    </item>
    
    <item>
      <title>jzoj5415题解</title>
      <link>http://blog.eleele.gq/post/jzoj5415/</link>
      <pubDate>Mon, 23 Oct 2017 13:57:08 +0000</pubDate>
      
      <guid>http://blog.eleele.gq/post/jzoj5415/</guid>
      <description>首先注意到，对于c一样且i%c一样的车站，它们能转移到的车站集合是一样的。考虑这些车站，它们对后面的车站的贡献都可以写成直线v[i]/ci+f[i]的形式。在后面转移的时候，其实就是要求在某一个横坐标的位置所有直线的最低点，此时有一个很自然的想法就是维护一个上凸壳。
这个凸壳乍一看很不好维护，但是仔细想一想会发现，每次新加进来一条直线的时候，这条直线在i处的高度肯定不比凸壳上任意一条直线要高（否则就可以用比当前直线低的直线来更新f[i])。那么，如果这条新加进来的直线的斜率小于等于凸壳上某条直线的斜率，凸壳上那条直线就没有用了，可以直接去掉。我觉得这道题最妙的就是这个性质，以前遇到类似的题没想出来，这回做的时候还是没想出来……
利用这个性质，就可以保证直线的斜率单调递增，从而用单调栈来维护上凸壳。
对于本题，总共需要维护maxc*maxc个凸壳，每次查询的时候要考虑maxc个。
时间复杂度$O(n\times\mathrm{maxc})$。
代码：
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #define ele int using namespace std; #define maxn 1000010 #define maxc 11 const ele INF=1e9; struct line{ double k,b; }; inline double calc(line a,line b){ return (b.b-a.b)/(a.k-b.k); } ele n,mc,c[maxn],v[maxn],f[maxn]; vector&amp;lt;line&amp;gt; s[maxc][maxc]; int main(){ //	freopen(&amp;quot;bus.in&amp;quot;,&amp;quot;r&amp;quot;,stdin); //	freopen(&amp;quot;bus.out&amp;quot;,&amp;quot;w&amp;quot;,stdout); scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;mc); for (int i=0; i&amp;lt;n; ++i) scanf(&amp;quot;%d%d&amp;quot;,c+i,v+i); f[0]=0; for (int i=0; i&amp;lt;n; ++i){ if (f[i]&amp;lt;INF){ line l=(line){(double)v[i]/c[i],-(double)v[i]/c[i]*i+f[i]}; while (s[c[i]][i%c[i]].</description>
    </item>
    
  </channel>
</rss>