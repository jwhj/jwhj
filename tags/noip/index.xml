<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Noip on 蒟蒻的博客</title>
    <link>http://blog.eleele.gq/tags/noip/</link>
    <description>Recent content in Noip on 蒟蒻的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 24 Oct 2017 13:53:30 +0000</lastBuildDate>
    
	<atom:link href="http://blog.eleele.gq/tags/noip/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>纪中模拟赛10-24总结</title>
      <link>http://blog.eleele.gq/post/jz10-24/</link>
      <pubDate>Tue, 24 Oct 2017 13:53:30 +0000</pubDate>
      
      <guid>http://blog.eleele.gq/post/jz10-24/</guid>
      <description>开考的时候先看了一眼T1，发现题面似乎有点问题，于是跳到T2。
看T2的时候，马上想到拓扑序列计数，然而并不会做，还忽略了每个点出度不超过1这个条件。
于是我打了一下T2的暴力，回去看T1，发现题面已经更正了，就打了暴力和正解放在一遍拍着。接着我回去想T2，卡了很久没想出来，最后看到之前忽略了的那个条件，然后……就秒掉了。
此时只剩下1h，我变得很慌，T3成功5分滚粗。
最后看成绩0+100+5=105
T1的话，数据应该是错了，经胡乱修改+测试，数据更正的话我应该能100，这个就没啥可说了。
T2我读错题这个过于sb。以后看到题，就算有想法，也一定要坚持仔细读完题目，因为这个想法未必是对的，而且这样很容易漏条件，我好像就漏过好几次了。
T3滚粗主要还是因为太慌没想清楚？中午吃饭的时候随便想想也就会做了。不过挺考码力的，另外如果写成$O(q\log^2 n)$的话需要优化一下才能过。我采取的优化主要是，寻找左右第一个可行位置时，直接在线段树上二分，省去这部分的一个log，再用预编译命令开O2。不知道为什么预编译命令开的O2好像没有直接命令行开O2快？
题解就不写了，还是挺简单的。
代码（T1）：
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #define ele long long using namespace std; #define maxn 810 #define maxk 10 const ele INF=1e9; ele n,m,q,_log[maxn],a[maxn][maxn],b[maxn][maxn]; struct st{ ele a[maxn][maxn],f[maxn][maxn][maxk]; inline void init(){ for (int i=0; i&amp;lt;n; ++i) for (int j=0; j&amp;lt;m; ++j) f[i][j][0]=a[i][j]; for (int k=1; k&amp;lt;maxk; ++k) for (int i=0; i&amp;lt;n; ++i) for (int j=0; j&amp;lt;m; ++j){ f[i][j][k]=f[i][j][k-1]; ele L=1&amp;lt;&amp;lt;(k-1); if (i+L&amp;lt;n) f[i][j][k]=min(f[i][j][k],f[i+L][j][k-1]); if (j+L&amp;lt;m) f[i][j][k]=min(f[i][j][k],f[i][j+L][k-1]); if (i+L&amp;lt;n &amp;amp;&amp;amp; j+L&amp;lt;m) f[i][j][k]=min(f[i][j][k],f[i+L][j+L][k-1]); } } inline ele qry(ele i,ele j,ele L){ ele k=_log[L],L1=1&amp;lt;&amp;lt;k; ele ans=INF; ans=min(ans,f[i][j][k]); ans=min(ans,f[i+L-L1][j][k]); ans=min(ans,f[i][j+L-L1][k]); ans=min(ans,f[i+L-L1][j+L-L1][k]); return ans; } inline ele qry(ele x1,ele y1,ele x2,ele y2){ ele Lx=x2-x1+1,Ly=y2-y1+1; ele ans=INF; if (Lx&amp;lt;Ly){ for (ele y=y1; y&amp;lt;=y2; y+=Lx) ans=min(ans,qry(x1,min(y,y2-Lx+1),Lx)); } else{ for (ele x=x1; x&amp;lt;=x2; x+=Ly) ans=min(ans,qry(min(x,x2-Ly+1),y1,Ly)); } return ans; } }qmx,qmn; int main(){ //	freopen(&amp;quot;phalanx.</description>
    </item>
    
    <item>
      <title>2017国庆雅礼集训总结</title>
      <link>http://blog.eleele.gq/post/yali2017/</link>
      <pubDate>Sun, 22 Oct 2017 02:23:28 +0000</pubDate>
      
      <guid>http://blog.eleele.gq/post/yali2017/</guid>
      <description>外省的dalao都好强啊……长跪不起啊……
湖南的菜好辣啊……只能靠外卖度日啊……
应该会断断续续地写完……吧？
考场上A了的可能就不写了？
D4 T3 模板题……可惜我太弱没写出来……
f[i][j]表示a只考虑0~i，b只考虑0~j，且b[j]必须选的最长长度。
如果a[i]!=b[j]，f[i][j]=f[i-1][j]
否则可以证明一定是a[i]与b[j]配对。如果直接暴力寻找转移点，最后的复杂度是立方的。可以维护一个max，每次外层循环置0，内层循环中，如果a[i]&amp;gt;b[j]，用f[i-1][j]来更新max，a[i]=b[j]进行转移的时候，f[i][j]=max+1就可以了。
代码：
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #define ele int using namespace std; #define maxn 5010 ele n,m,len,a[maxn],b[maxn],f[maxn][maxn],g[maxn][maxn]; void put(ele i,ele j){ if (!i || !j) return; put(i-1,g[i][j]); printf((i==n)?&amp;quot;%d\n&amp;quot;:&amp;quot;%d &amp;quot;,b[j]); } int main(){ len=0; scanf(&amp;quot;%d&amp;quot;,&amp;amp;n); for (int i=0; i&amp;lt;n; ++i) scanf(&amp;quot;%d&amp;quot;,a+i+1); scanf(&amp;quot;%d&amp;quot;,&amp;amp;m); for (int i=0; i&amp;lt;m; ++i) scanf(&amp;quot;%d&amp;quot;,b+i+1); memset(f,0,sizeof(f)); for (int i=1; i&amp;lt;=n; ++i){ ele mx=0,p=0; for (int j=1; j&amp;lt;=m; ++j){ if (a[i]==b[j]) f[i][j]=mx+1,g[i][j]=p; else f[i][j]=f[i-1][j],g[i][j]=g[i-1][j]; if (a[i]&amp;gt;b[j] &amp;amp;&amp;amp; f[i-1][j]&amp;gt;mx) mx=f[i-1][j],p=j; } } ele ans=0,p; for (int i=1; i&amp;lt;=m; ++i) if (f[n][i]&amp;gt;ans) ans=f[n][i],p=i; printf(&amp;quot;%d\n&amp;quot;,ans); put(n,p); return 0; }  D5 T3 妙啊……</description>
    </item>
    
    <item>
      <title>noip2016题解</title>
      <link>http://blog.eleele.gq/post/noip2016/</link>
      <pubDate>Mon, 21 Nov 2016 10:02:43 +0000</pubDate>
      
      <guid>http://blog.eleele.gq/post/noip2016/</guid>
      <description>&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>